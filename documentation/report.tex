\documentclass[titlepage]{article}
\usepackage{fullpage}
\usepackage{graphicx}

\renewcommand{\thesection}{\Roman{section}}

\begin{document}

\title{17-614 Formal Methods\\[1ex] Project: Structural Modeling}
\author{
	{\Large\textbf{Team 16}}\\[3ex]
	yashanan\\[1ex] salonisi\\[1ex] halkhala\\[1ex] ktakayam}
\date{\today}
\maketitle

\newpage

\section{Task 1}
\subsection{Include an object model diagram for your system.}

Below is the final version of our object model diagram. Note that the privacy levels in the below model are singleton sets, so we have used rounded corners to represent them.

\includegraphics[width=6in]{images/single_model.png}

However, this model holds true only for a ‘snapshot’ of a single Nicebook. Below is the true model (that always holds), where we have redefined some object constraints to accommodate multiple Nicebook situations that arise when modeling actions (see section II.2.2). For e.g., some Content can be owned by two different users, given that they belong to different Nicebooks - a situation that arises during addPhoto when we need to copy a User to preserve all their existing Content.

\includegraphics[width=6in]{images/true_model.png}

\subsection{Describe any decisions that your team made in resolving ambiguities in the English document. Also describe alternatives you considered and rejected.}

The decisions we made during the modeling process fall roughly into two categories: “Feature decisions” and “Internal modeling decisions”.
\subsubsection{Feature Decisions}
These are decisions we made regarding features that are exposed to the users.
\begin{enumerate}
\item\textbf{Privacy Settings}\\
There are three types of privacy settings defined in the project specification:
\begin{enumerate}
	\item Each piece of content owned by a user is associated with a privacy level that determines who can view that content on the user’s account.
	      \begin{enumerate}
		      \item We have defined a relationship contentViewPrivacy: Content $\rightarrow$ PrivacyLevel which is a content-specific setting that controls who related to the user can view user-owned content.
	      \end{enumerate}
	\item Each user has a setting that controls who can view content that is published on the user’s account by other users.
	      \begin{enumerate}
		      \item We assume that comments posted (both direct and nested) on user-owned content are considered content published by other users on the user’s account.
		      \item We have defined a relationship userViewPrivacy: User $\rightarrow$ PrivacyLevel which is a user-specific setting that controls viewing privileges for comments attached to user-owned content.
	      \end{enumerate}
	\item Each user has a setting that controls who can add a comment to content that is owned by the user.
	      \begin{enumerate}
		      \item We have defined a relationship commentPrivacy: User $\rightarrow$ PrivacyLevel which is a user-specific setting that controls who can comment on user-owned content.
	      \end{enumerate}
\end{enumerate}
\item\textbf{Content Viewing Priveleges}
\begin{enumerate}
	\item The getContentsInState[s: Nicebook] function returns the set of Content that belongs to the state s. A Content instance belongs to a state if the owner of the content as well as the owners of all parent contents (if any) belong to the state. In the below example, Comment belongs to S1 in the left state-chart since its user as well as the owner of its parent Content (Photo) belong to the state S1. However, in the right diagram, the owner of Comment belongs to S1, but since the owner of its parent Content does not belong to S2, Comment does not belong to S1 in the right diagram.

	      \includegraphics[width=6in]{images/content_view_1.png}

	\item We have defined a function called canView which takes a User instance and a Nicebook instance (representing the state) as arguments and returns the set of Contents that the user can view in a given state. A user can view Content if all of the following conditions hold:

	      \begin{enumerate}
		      \item The content belongs to the state
		      \item The user has viewing privileges for the said content as defined in the contentViewPrivacy relation.
		      \item If the user has parent elements, the user must have privileges to view the “children” elements of parent elements. This is defined in the userViewPrivacy relation.
		      \item All the above conditions must satisfy for the content at hand as well as all parent elements of the said content – In short, a content can only be viewed if all its parent contents can also be viewed.
	      \end{enumerate}
	      \item\textbf{Exception: A user can view all comments and nested comments on content owned by him/her regardless of the contentViewPrivacy and userViewPrivacy settings defined by those comments and owners of those comments respectively.}
\end{enumerate}
\item\textbf{Commenting Priveleges}
\begin{enumerate}
\item We have defined a function canCommentOn[u: User, s : Nicebook] which returns the set of Contents that the user can comment on. A user can comment on a content if the following conditions hold:
\begin{enumerate}
	\item The user can view the content as defined in the canView function.
	\item The user has commenting privileges as defined by the content owner in the commentPrivacy relation.

	\item The above conditions must hold true for all its parent content elements, if any.
\end{enumerate}
\item\textbf{Exception: A user can comment on comments and nested comments that are attached to contents owned by the user, regardless of the commentPrivacy settings set up by owners of those nested comments.}
\item\textbf{Operation Priveleges}
\begin{enumerate}
	\item \underline{Adding a photo}: Any user can perform this action. When a photo is added by a user, the relationship “owns” is established between the user and the photo.
	\item \underline{Deleting a photo}: A photo can be deleted by the owner of the photo only.
	\item \underline{Adding a comment}: To add a comment on an instance of Content, the following conditions must hold true:
	      \begin{enumerate}
		      \item The user must have commenting privileges on content as defined in the canCommentOn function.
	      \end{enumerate}
	\item \underline{Deleting a comment}: In order to delete a comment, either of the following must hold:
	      \begin{enumerate}
		      \item The user is the owner of the comment
		      \item The user is the owner of one of the parent elements of the said comment.
		            \end {enumerate}
		      \item \underline{Adding a tag}: A user can tag another user on a photo if the following holds true:
		            \begin{enumerate}
			            \item Both users have the privilege of viewing the Photo.
			            \item The two users are friends in the same state
		            \end{enumerate}
		      \item \underline{Removing a tag}: A user can remove a tag if any one or more of the following conditions holds true:
		            \begin{enumerate}
			            \item The user is the owner of the Photo which is tagged.
			            \item The user is tagged on a Photo and wants to remove his/her own tag from the Photo.
			            \item The user has tagged another user on a Photo and now wants to remove this tag.
		            \end{enumerate}
	      \end{enumerate}
	      \end{enumerate}
\end{enumerate}

\subsubsection{Internal Modeling Decisions}
These are internal alloy-related modeling decisions that do not affect what a user sees but how we choose to model our system.
\begin{enumerate}
	\item \textbf{Modeling Tags}
\end{enumerate}

\subsection{Describe any invariants that are not explicitly mentioned in the given document but were discovered during the modeling process.}
\subsection{Describe an invariant that was violated by an operation in your model and how it was fixed.}
\subsection{List the scope used for the analysis of invariant preservation. Why did you choose this scope, and why do you
	think it is sufficient?}

\section{Task 2}
\subsection{Define an Alloy function called canView, which takes at least one parameter that represents some user in the
	social network, and returns the set of all content that can be viewed by that user. You may use any number of
	helper predicates or functions to define canView.}

See the alloy code we implemented.

\subsection{You will use canView to check whether it is possible for a user to access a piece of content against the intent of the owner. In particular, we say that a privacy violation has occurred if a user is able to view a piece of content without adhering to the privacy level that is assigned to the content by its owner. For example, suppose that Alice
	and Bob are not friends, and Alice has a photo that is assigned privacy setting Friends; if Bob is able to view the
	photo, this would be considered a privacy violation. Define an Alloy assertion called NoPrivacyViolation
	to check that no such violation is possible.}

See the alloy code we implemented.

\subsection{Does your model satisfy NoPrivacyViolation? If so, explain why. If not, include a counterexample that
	demonstrates a violation, and suggest a modification to the design of privacy settings in Nicebook. Describe
	any alternatives you considered and rejected, along with justifications for your decision.}

Our model satisfies NoPrivacyViolation. \\
In the model instance below, if User C is able to view the Comment owned by User B, this is a violation of NoPrivacyViolation Because of the following
\begin{itemize}
	\item The Comment's contentViewPrivacy is PL\_Friends and this allows User C to view he/she is friends with the owner of the Comment: User B.
	\item All parent elements of the Comment are also viewable to User C as the Photo's contentViewPrivacy is set to PL\_Everyone.
	\item However, User A has userViewPrivacy = PL\_Friends which only allows friends of User A to view comments on contents owned by User A. Since Comment is a comment on a Photo owned by User A, it should not be viewable to User C.
\end{itemize} 

\includegraphics[width=6in]{images/privacy_violation.png}


\section{Task 3}
\subsection{What are the strengths and weaknesses of Alloy and its tool, the Alloy Analyzer?}
\subsubsection{Strengths of Alloy}
\begin{enumerate}
	\item \textbf{Powerful Relational Logic} \\
	The most used operator in our project is the relational join. It is similar to the object oriented language but more powerful. For example, in java emp.dept.mng will return the manager of the department which the employee belongs to, while in alloy this will work even if the emp is a set of employees, dept is a set of departments and/or mng is a set of managers. Also, in Alloy we can navigate to the backward relation as well.
	\item \textbf{Powerful Model Design and Representation} \\
	Alloy makes it easy to describe a universe of objects as a classification tree, with each relation defined over nodes in this tree. Which makes it easy to visualize the model and relation. Alloy Analyzer can generate a comprehensive graphical representation of the sets and relations from the signature declarations.
	\item \textbf{Limit Scope Analysis} \\
	We can have a small scope that bounds each of the types in the specification. A scope of five, for example, would include tests involving at most five elements of each type.
	\item \textbf{Abstraction} \\
	An abstract signature has no elements that do not belong to a child signature, and the extensions of a signature are disjoint. 
\end{enumerate}
\subsubsection{Weaknesses of Alloy}
\begin{enumerate}
	\item \textbf{Ambiguity in the Inconsistency Error} \\
	When there is an inconsistency error, Alloy does not specify where its section or line of code is, which makes it too hard to figure out the problem, especially when we work in a large system.
	\item \textbf{There is a Chance to Improve the Presentation of Different States} \\
	Alloy is representing two different objects for the same signature, the first one presenting the current state and the other representing the post state. This leads to many issues in our project, but we handle this in our project by providing extra constraints and invariants related to states.
\end{enumerate}
\subsection{Under what situations would you recommend its use (or not)? Why?}
Software nowadays is involved in each and every aspect of our life. In communication, healthcare, transportation, airlines, agriculture, network, civil engineering, commerce, … and so on. So when designing a software system, we need to be able to express the structures essential to the design and to check that they have the properties we expect. If we checked the structure model manually, we couldn’t identify each behavior in the system. Using automated modeling tools like alloy is essential especially if the system is critical (and its minor bad state will result in huge impact)

We strongly recommend using alloy as a modeling tool. It is an easy and powerful language and shows its success in many huge projects. Alloy allows every possible behavior for the model, as we add constraints, the behavior is limited.

\subsection{With respect to this notation, what is the single most-important future development that would be needed to
	make it more generally useful to practitioners?}

	Precise error trace specification for the inconsistency counter example. Refer to the first point in weaknesses of Alloy in the first question in Task 3.


\end{document}
